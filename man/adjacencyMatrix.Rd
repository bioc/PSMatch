% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adjacencyMatrix-create.R,
%   R/adjacencyMatrix-plot.R
\name{adjacencyMatrix}
\alias{adjacencyMatrix}
\alias{makeAdjacencyMatrix}
\alias{makePeptideProteinVector}
\alias{plotAdjacencyMatrix}
\title{Convert to/from an adjacency matrix.}
\usage{
makeAdjacencyMatrix(
  x,
  split = ";",
  peptide = psmVariables(x)["peptide"],
  protein = psmVariables(x)["protein"],
  binary = FALSE
)

makePeptideProteinVector(m, collapse = ";")

plotAdjacencyMatrix(x, layout = igraph::layout_as_bipartite)
}
\arguments{
\item{x}{A peptide-by-protein adjacency matrix.}

\item{split}{\code{character(1)} defining how to split the string of
protein identifiers (using \code{\link[=strsplit]{strsplit()}}). Default is ";". If
\code{NULL}, splitting is ignored.}

\item{peptide}{\code{character(1)} indicating the name of the variable
that defines peptides in the \code{PSM} object. Default is the
\code{peptide} PSM variable as defined in \code{\link[=psmVariables]{psmVariables()}}.}

\item{protein}{\code{character(1)} indicating the name of the variable
that defines proteins in the \code{PSM} object. Default is the
\code{peptide} PSM variable as defined in \code{\link[=psmVariables]{psmVariables()}}.Default
is \code{DatanbaseAccess}.}

\item{binary}{\code{logical(1)} indicates if the adjacency matrix
should be strictly binary. In such case, PSMs matching the
same peptide but from different precursors (for example charge
2 and 3) or carrying different PTMs, are counted only
once. Default if \code{FALSE}.}

\item{m}{An adjacency matrix.}

\item{collapse}{\code{character(1)} indicating how to collapse protein
names for shared peptides. Default is \code{";"}.}

\item{layout}{A graph layout, as defined in the \code{ipgraph}
package. Default is \code{\link[=layout_as_bipartite]{layout_as_bipartite()}}.}
}
\value{
A peptide-by-protein sparce adjacency matrix (or class
\code{dgCMatrix} as defined in the \code{Matrix} package) or
peptide/protein vector.
}
\description{
There are two ways that peptide/protein matches are commonly
stored: either as a vector or an adjacency matrix. The functions
described below convert between these two format.
}
\details{
The \code{\link[=makeAdjacencyMatrix]{makeAdjacencyMatrix()}} function creates a peptide-by-protein
adjacency matrix from a \code{character} or an instance of class
\code{\link[=PSM]{PSM()}}.

The character is formatted as \code{x <- c("ProtA", "ProtB", "ProtA;ProtB", ...)}, as commonly encoutered in proteomics data
spreadsheets. It defines that the first peptide is mapped to
protein "ProtA", the second one to protein "ProtB", the third one
to "ProtA" and "ProtB", and so on. The resulting matrix contain
\code{length(x)} rows an as many columns as there are unique protein
idenifiers in \code{x}. The columns are named after the protein
idenifiers and the peptide/protein vector namesa are used to name
to matrix rows (even if these aren't unique).

The \code{\link[=makePeptideProteinVector]{makePeptideProteinVector()}} function does the opposite
operation, taking an adjacency matrix as input and retruning a
peptide/protein vector. The matrix colnames are used to populate
the vector and the matrix rownames are used to name the vector
elements.

Note that when creating an adjacency matrix from PSMs, the matrix
is not necessarily binary, as multiple PSMs can match the same
peptide (sequence), such as for example precursors with different
charge states. A binary matrix can either be generated with the
\code{binary} argument (setting all non-0 values to 1) or by reducing
the PSM object accordingly (see example below).

The \code{plotAdjacencyMatrix()} function is useful to visualise small
adjacency matrices, such as those representing protein groups
modelled as connected components, as described and illustrated in
\code{\link[=ConnectedComponents]{ConnectedComponents()}}.
}
\examples{

## -----------------------
## From a character
## -----------------------

## Protein vector without names
prots <- c("ProtA", "ProtB", "ProtA;ProtB")
makeAdjacencyMatrix(prots)

## Named protein vector
names(prots) <- c("pep1", "pep2", "pep3")
prots
m <- makeAdjacencyMatrix(prots)
m

## Back to vector
vec <- makePeptideProteinVector(m)
vec
identical(prots, vec)

## ---------------------------
## PSM object from a dat.frame
## ---------------------------

psmdf <- data.frame(psm = paste0("psm", 1:10),
                    peptide = paste0("pep", c(1, 1, 2, 2, 3, 4, 6, 7, 8, 8)),
                    protein = paste0("Prot", LETTERS[c(1, 1, 2, 2, 3, 4, 3, 5, 6, 6)]))
psmdf
psm <- PSM(psmdf, peptide = "peptide", protein = "protein")
psm
makeAdjacencyMatrix(psm)

## Reduce PSM object to peptides
rpsm <- reducePSMs(psm, k = psm$peptide)
rpsm
makeAdjacencyMatrix(rpsm)

## Or set binary to TRUE
makeAdjacencyMatrix(psm, binary = TRUE)

## ----------------------------
## PSM object from an mzid file
## ----------------------------

f <- msdata::ident(full.names = TRUE, pattern = "TMT")
psm <- PSM(f) |>
       filterPsmDecoy() |>
       filterPsmRank()
psm
adj <- makeAdjacencyMatrix(psm)
dim(adj)
adj[1:10, 1:4]

## Binary adjacency matrix
adj <- makeAdjacencyMatrix(psm, binary = TRUE)
adj[1:10, 1:4]

## Peptides with rowSums > 1 match multiple proteins.
## Use filterPsmShared() to filter these out.
table(rowSums(adj))
}
\author{
Laurent Gatto
}
